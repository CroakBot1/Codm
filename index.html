<!DOCTYPE html>
<html lang="ceb">
<head>
    <title>COD PWA Aimbot/ESP</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="manifest" id="manifest-link">
    <style>
        body { margin: 0; background: black; font-family: Arial; overflow: hidden; }
        #video { display: none; }
        #canvas, #overlay { position: absolute; top: 0; left: 0; }
        #overlay { pointer-events: none; }
        #controls {
            position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.7);
            padding: 10px; border-radius: 5px; z-index: 10; max-width: 300px;
        }
        #controls label { display: block; margin: 5px 0; font-size: 12px; }
        #controls input { width: 60px; }
        #info { font-weight: bold; color: lime; }
        button { margin: 2px; padding: 5px 10px; }
    </style>
</head>
<body>
    <video id="video" autoplay muted playsinline></video>
    <canvas id="canvas"></canvas>
    <canvas id="overlay"></canvas>
    <div id="controls">
        <button id="start">Start Capture</button>
        <button id="stop">Stop</button>
        <button id="fullscreen">Fullscreen</button>
        <label>FOV Radius: <input id="fov" type="range" min="50" max="400" value="150"><span id="fovval">150</span>px</label>
        <label>Enemy Color Tune (Red Outline):</label>
        <label>R Min: <input id="rmin" type="number" value="200" min="0" max="255"> Max: <input id="rmax" value="255" min="0" max="255"></label>
        <label>G Min: <input id="gmin" value="0" min="0" max="255"> Max: <input id="gmax" value="50" min="0" max="255"></label>
        <label>B Min: <input id="bmin" value="0" min="0" max="255"> Max: <input id="bmax" value="50" min="0" max="255"></label>
        <label>Min Hits: <input id="minhits" type="number" value="10" min="5" max="50"></label>
        <div id="info">Ready</div>
    </div>
    <script>
        // PWA Manifest
        const manifest = {
            name: "COD Aimbot PWA",
            short_name: "CodAim",
            start_url: "./",
            display: "standalone",
            background_color: "#000000",
            theme_color: "#000000",
            icons: [{
                src: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyIiBoZWlnaHQ9IjE5MiIgdmlld0JveD0iMCAwIDE5MiAxOTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxjaXJjbGUgY3g9Ijk2IiBjeT0iOTYiIHI9Ijk2IiBmaWxsPSIjRkYwMDAwIi8+CjxjaXJjbGUgY3g9Ijc1IiBjeT0iNzAiIHI9IjE1IiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K",
                sizes: "192x192",
                type: "image/svg+xml"
            }]
        };
        document.getElementById('manifest-link').href = 'data:application/json;base64,' + btoa(JSON.stringify(manifest));

        // Service Worker for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register(URL.createObjectURL(new Blob([`
                self.addEventListener('install', e => { self.skipWaiting(); });
                self.addEventListener('activate', e => { self.clients.claim(); });
                self.addEventListener('fetch', e => {
                    e.respondWith(fetch(e.request).catch(() => caches.match(e.request)));
                });
            `], { type: 'application/javascript' })));
        }

        // Game vars
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const overlay = document.getElementById('overlay');
        const ctx = canvas.getContext('2d', { alpha: false });
        const octx = overlay.getContext('2d');
        let stream = null;
        let raf = null;
        let processing = false;

        // Controls
        document.getElementById('fov').oninput = (e) => {
            document.getElementById('fovval').textContent = e.target.value;
        };
        document.getElementById('fullscreen').onclick = () => {
            if (canvas.requestFullscreen) canvas.requestFullscreen();
        };
        document.getElementById('start').onclick = async () => {
            try {
                stream = await navigator.mediaDevices.getDisplayMedia({
                    video: { mediaSource: 'screen' }
                });
                video.srcObject = stream;
                await video.play();
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                overlay.width = canvas.width;
                overlay.height = canvas.height;
                overlay.style.width = `${canvas.width}px`;
                overlay.style.height = `${canvas.height}px`;
                processing = true;
                processFrame();
                document.getElementById('info').textContent = 'Capturing... Tune colors!';
            } catch (err) {
                alert('Capture failed: ' + err);
            }
        };
        document.getElementById('stop').onclick = () => {
            if (stream) stream.getTracks().forEach(track => track.stop());
            processing = false;
            if (raf) cancelAnimationFrame(raf);
            octx.clearRect(0, 0, canvas.width, canvas.height);
            document.getElementById('info').textContent = 'Stopped';
        };

        function isEnemy(r, g, b) {
            const rmin = parseInt(document.getElementById('rmin').value);
            const rmax = parseInt(document.getElementById('rmax').value);
            const gmin = parseInt(document.getElementById('gmin').value);
            const gmax = parseInt(document.getElementById('gmax').value);
            const bmin = parseInt(document.getElementById('bmin').value);
            const bmax = parseInt(document.getElementById('bmax').value);
            return r >= rmin && r <= rmax && g >= gmin && g <= gmax && b >= bmin && b <= bmax;
        }

        function processFrame() {
            if (!processing) return;
            ctx.drawImage(video, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const w = canvas.width, h = canvas.height;
            const cx = w / 2, cy = h / 2;
            const radius = parseInt(document.getElementById('fov').value);
            const minHits = parseInt(document.getElementById('minhits').value);

            let sumX = 0, sumY = 0, count = 0;
            const step = 4; // Subsample for perf

            for (let y = Math.max(0, cy - radius); y < Math.min(h, cy + radius); y += step) {
                for (let x = Math.max(0, cx - radius); x < Math.min(w, cx + radius); x += step) {
                    const i = (Math.floor(y) * w + Math.floor(x)) * 4;
                    const r = data[i], g = data[i + 1], b = data[i + 2];
                    if (isEnemy(r, g, b)) {
                        sumX += x;
                        sumY += y;
                        count++;
                    }
                }
            }

            // Draw overlay
            octx.clearRect(0, 0, w, h);

            // FOV Circle
            octx.strokeStyle = 'yellow';
            octx.lineWidth = 2;
            octx.beginPath();
            octx.arc(cx, cy, radius, 0, Math.PI * 2);
            octx.stroke();

            // Center Crosshair
            octx.strokeStyle = 'white';
            octx.lineWidth = 2;
            octx.beginPath();
            octx.moveTo(cx - 30, cy); octx.lineTo(cx + 30, cy);
            octx.moveTo(cx, cy - 30); octx.lineTo(cx, cy + 30);
            octx.stroke();

            let info = 'No enemy';
            if (count >= minHits) {
                const targetX = sumX / count;
                const targetY = sumY / count;
                const dx = targetX - cx;
                const dy = targetY - cy;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Enemy Circle
                octx.strokeStyle = 'lime';
                octx.lineWidth = 3;
                octx.beginPath();
                octx.arc(targetX, targetY, 25, 0, Math.PI * 2);
                octx.stroke();

                // Aim Line
                octx.strokeStyle = 'red';
                octx.lineWidth = 4;
                octx.lineCap = 'round';
                octx.beginPath();
                octx.moveTo(cx, cy);
                octx.lineTo(targetX, targetY);
                octx.stroke();

                // Console log for AHK
                console.log(`Aim: dx=${Math.round(dx)} dy=${Math.round(dy)} dist=${Math.round(dist)} hits=${count}`);

                info = `Target: ${Math.round(dist)}px (${count} hits) dx:${Math.round(dx)} dy:${Math.round(dy)}`;
            }
            document.getElementById('info').textContent = info;

            raf = requestAnimationFrame(processFrame);
        }
    </script>
</body>
</html>
